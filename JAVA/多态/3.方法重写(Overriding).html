<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>阿东的知识库</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }
        /* 头部样式 */
       .header {
            background-color: #333;
            color: rgb(194, 53, 53);
            text-align: center;
            padding: 20px 0;
        }
        /* 整体布局容器 */
       .container {
            display: flex;
        }
        /* 侧边栏样式 */
       .sidebar {
            width: 200px;
            background-color: #ffffff; /* 设置侧边栏背景为白色 */
            min-height: 100vh;
            padding: 20px;
        }

        .sidebar ul h1
        {
            font-size: 1.5em;
            margin-top: 0;
            color: #120101;
        }

        /* 侧边栏ul无序列表样式 */
       .sidebar ul 
       {
            list-style-type: none;
            padding: 0;
        }
        /* 侧边栏li列表项样式 */
       .sidebar li
        {
            margin-bottom: 10px;
        }
        /* 侧边栏a超链接样式 */
       .sidebar li a 
       {
            text-decoration: none;
            color: #000;
            display: block;
            padding: 5px 10px;
            background-color: #f0f0f0; /* 设置列表项内容背景颜色 */
            border-radius: 5px; /* 为列表项添加圆角 */
            transition: background-color 0.3s ease; /* 添加背景颜色过渡效果 */
        }
       .sidebar li a:hover 
       {
            background-color: #ddd; /* 鼠标悬停时的背景颜色 */
            color: #007BFF;
        }
        /* 主内容区域样式 */
       .main-content 
       {
            flex: 1;
            padding: 20px;
        }
    </style>

</head>


<body>
    <!-- 头部区域 -->
    <div class="header">
        <h1>阿东的知识库</h1>
    </div>
    <!-- 开启弹性布局 -->
    <div class="container">
        <!-- 侧边栏 -->
        <div class="sidebar">
           
            <div id="target"></div>

            <script>
              const xhr = new XMLHttpRequest();
              xhr.open('GET', 'https://ruanzhaodong.github.io/JAVA-href/', true);
              xhr.onreadystatechange = function () 
              {
                if (xhr.readyState === 4 && xhr.status === 200)
                 {
                  const responseText = xhr.responseText;
                  const targetDiv = document.getElementById('target');
                  targetDiv.innerHTML = responseText;
                }
              };
              xhr.send();
            </script>


        </div>

        <!-- 主内容区域 -->
        <div class="main-content">
            <h1>Java 方法重写概念</h1>

            <h2>什么是方法重写</h2>
            <p>方法重写（Method Overriding）是 Java 中实现多态性的重要手段之一，它发生在具有继承关系的子类和父类之间。当子类继承父类的方法后，若子类需要对该方法进行不同的实现，就可以在子类中重新定义与父类中具有相同名称、参数列表和返回类型的方法，此即方法重写。</p>
            <hr>
            
            <h2>方法重写的条件</h2>
            <ol>
                <li><strong>方法名相同</strong>：子类重写的方法名必须与父类被重写的方法名一致。</li>
                <li><strong>参数列表相同</strong>：参数的个数、类型和顺序都要与父类方法保持一致。</li>
                <li><strong>返回类型兼容</strong>：在 Java 5 及以后版本中，子类重写方法的返回类型可以是父类被重写方法返回类型的子类；在 Java 5 之前，返回类型必须完全相同。</li>
                <li><strong>访问修饰符限制</strong>：子类重写方法的访问修饰符不能比父类被重写方法的访问修饰符更严格。例如，若父类方法是 `public`，子类重写方法不能是 `private` 或 `protected`。</li>
                <li><strong>异常抛出限制</strong>：子类重写方法不能抛出比父类被重写方法更多的异常类型，只能抛出相同的异常或者其子类异常。</li>
            </ol>
            <hr>
            
            <h2>方法重写示例</h2>
            <pre>
            // 父类
            class Animal {
            public void makeSound() {
                System.out.println("动物发出声音");
            }
            }
            
            // 子类
            class Dog extends Animal {
            @Override
            public void makeSound() {
                System.out.println("汪汪汪");
            }
            }
            
            public class Main {
            public static void main(String[] args) {
                Animal animal = new Animal();
                animal.makeSound();
            
                Dog dog = new Dog();
                dog.makeSound();
            
                Animal animalDog = new Dog();
                animalDog.makeSound();
            }
            }
            </pre>
            <p>在上述示例中，`Dog` 类继承自 `Animal` 类，并重写了 `makeSound` 方法。当调用 `dog.makeSound()` 时，会执行子类重写后的方法。同时，通过多态的方式 `Animal animalDog = new Dog();` 调用 `makeSound` 方法，也会执行子类重写后的方法，这体现了方法重写在多态中的应用。</p>
            <hr>

            <h2>方法重写与方法重载的区别</h2>
            <table border="1">
                <tr>
                    <th>比较项</th>
                    <th>方法重写</th>
                    <th>方法重载</th>
                </tr>
                <tr>
                    <td>定义位置</td>
                    <td>发生在具有继承关系的子类和父类之间</td>
                    <td>发生在同一个类中</td>
                </tr>
                <tr>
                    <td>方法名</td>
                    <td>必须相同</td>
                    <td>必须相同</td>
                </tr>
                <tr>
                    <td>参数列表</td>
                    <td>必须相同</td>
                    <td>必须不同</td>
                </tr>
                <tr>
                    <td>返回类型</td>
                    <td>兼容或相同</td>
                    <td>可以不同</td>
                </tr>
                <tr>
                    <td>访问修饰符</td>
                    <td>子类不能更严格</td>
                    <td>无限制</td>
                </tr>
            </table>
            
            <hr>
            
            
            <h2>方法重写的优点</h2>
            <ul>
                <li><strong>实现多态</strong>：通过方法重写和多态机制，使得程序可以根据对象的实际类型来调用相应的方法，提高了程序的灵活性和可扩展性。</li>
                <li><strong>代码复用与扩展</strong>：子类可以复用父类的方法框架，同时根据自身需求进行个性化的实现，避免了代码的重复编写。</li>
                <li><strong>符合开闭原则</strong>：当需要对系统进行功能扩展时，可以通过子类重写父类方法的方式来实现，而不需要修改父类的代码，增强了系统的稳定性和可维护性。</li>
            </ul>
            <hr>
            
            <h2>总结</h2>
            <p>方法重写是 Java 面向对象编程中的一个重要特性，它允许子类根据自身的需求对父类的方法进行重新定义，从而实现多态性和代码的灵活扩展。在使用方法重写时，需要遵循一定的规则，以确保程序的正确性和可维护性。</p>
        </div>

    </body>

</html>
        